package com.com.thinkinginjava7;

/**
 * Created by xuxi on 2019/2/26.
 */

/**
 * 初始化及类的加载
 *
 * 在许多传统语言中，程序是作为启动过程的一部分立刻被加载的。然后初始化，紧接着
 * 程序开始运行。这些语言的初始化过程必须小心控制，以确保定义为static的东西，其
 * 初始化顺序不会造成麻烦。例如C++中，如果某个static期望另一个static在被初始化
 * 之前就能有效地使用它，那么就会出现问题。
 *
 * Java就不会出现这个问题，因为它采用了一种不同的加载方式。加载是众多变得更加容易
 * 的动作之一，因为Java中的所有事物都是对象。请记住，每个类的编译代码都存在于自己的
 * 独立的文件中。该文件只在需要使用程序代码时才会被加载。一般来说，可以说："类的代码在
 * 初次使用时才加载。"这通常是指加载发生于创建类的第一个对象之时，但是当访问static域
 * 或static方法时，也会发生加载。（构造器也是static方法。尽管static关键字并没有显式
 * 地写出来。因此更准确地讲，类是在其任何static成员被访问时加载的。）
 *
 * 初次使用之处也是static初始化发生之处。所有的static对象和static代码段都会在加载时
 * 依程序中的顺序（即，定义类时的书写顺序）而依次初始化。当然，定义为static的东西只会被
 * 初始化一次。
 */

/**
 * 继承与初始化
 *
 * 了解包括继承在内的初始化全过程，以对所发生的一切有个全局性的把握，是很有益的。
 */

class Insect {
    private int i = 9;
    protected int j;
    Insect(){
        System.out.println("i = " + i + " j = " + j);
        j = 39;
    }

    private static int x1 = printInit("static Inserct.x1 initialized");
    static int printInit(String s){
        System.out.println(s);
        return 47;
    }
}

public class Beetle extends Insect{

    private int k = printInit("Beetle.k initialized");
    public Beetle(){
        System.out.println("k = " + k);
        System.out.println("j = " + j);
    }
    private static int x2 = printInit("static Beetle.x2 initialized");

    public static void main(String[] args) {
        System.out.println("Beetle constructor");
        Beetle b = new Beetle();
    }

}
/**
 * 在Beetle上运行Java时，所发生的第一件事情就是试图访问Beetle.main()(一个static方法)，
 * 于是加载器开始启动并找出Beetle类的编译代码（在名为Beetle.class的文件之中）。在对它进行
 * 加载的过程中，编译器注意到它有一个基类（这是由关键字extends得知的），于是它继续进行加载。
 * 不管你是否打算产生一个该基类的对象，这都要发生（请尝试将对象创建代码注释掉，以证明这一点）
 *
 * 如果该基类还有其自身的基类，那么第二个基类就会被加载，如此类推。接下来，根基类中的static
 * 初始化（在此例中为Inserct）即会被执行，然后是下一个导出类，以次类推。这种方式很重要，因为
 * 导出类的static初始化可能会依赖于基类成员能否被正确初始化。
 *
 * 至此为止，必要的类都已加载完毕，对象就可以被创建了。首先，对象中所有的基本类型都会设为默认值，
 * 对象引用被设为null—————这是通过将对象内存设为二进制零值而一举生成的。然后，基类的构造器会被
 * 调用。在本例中，它是被自动调用的。但也可以用super来指定对基类构造器的调用（正如在Beetle()
 * 构造器中的第一步操作）。基类构造器和导出类的构造器一样，以相同的顺序经历相同的过程。在基类构造器
 * 完成之后，实例变量按其次序被初始化。最后，构造器的其余部分被执行。
 *
 */
/**
 * 继承和组合都能从现有类型生成新类型。组合一般是将现有类型作为新类型底层实现的一部分
 * 来加以复用，而继承复用的是接口。
 * 在使用继承时，由于导出类具有基类接口，因此它可以向上转型至基类，这对多态来将至关重要
 * ，就像我们将在下一章中将要看到的那样。
 * 尽管面向对象编程对继承极力强调，但在开始一个设计时，一般应优先选择使用组合（或者可能是代理），
 * 只在确实必须时才使用继承。因为组合更具灵活型。此外，通过对成员类型使用继承技术的添加技巧，
 * 可以在运行时改变那些成员对象的类型和行为。因此，可以在运行时改变组合而成的对象的行为。
 * 在设计一个系统时，目标应该是找到或创建某些类，其中每个类都有具体的用途，而且既不会太大（包含
 * 太多的功能而难以复用），也不会太小（不添加其他功能就无法使用）。如果你的设计变得过于复杂，通过
 * 将现有类拆分为更小的部分而添加更多的对象，通常会有所帮助。
 * 当你开始设计一个系统时，应该认识到程序开发是一种增量过程，犹如人类的学习一样，这一点很重要。程序
 * 开发依赖于实验，你可以尽己所能去分析，但当你开始执行一个项目时，你仍然无法知道所有的答案。如果将
 * 项目视作是一种有机的、进化着的生命体而去培养，而不是打算像盖摩天大楼一样快速见效，就会获得更多的
 * 成功和更迅速的回馈。继承和组合正是在面向对象程序设计中使得你可以执行这种实验的最基本的两个工具。
 */