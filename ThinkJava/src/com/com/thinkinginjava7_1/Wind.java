package com.com.thinkinginjava7_1;

/**
 * Created by xuxi on 2019/2/25.
 */

/**
 * "为新的类提供方法"并不是继承技术中最重要的方面，其最重要的方面是用来表现新类和
 * 基类之间的关系。这种关系可以用"新类是现有类的一种类型"这句话加以概括。
 * 这个描述并非只是一种解释继承的华丽的方式，这直接是由语言所支撑的。
 */
class Instrument{
    public void play(){}
    static void tune(Instrument i){
        i.play();
    }
}

public class Wind extends Instrument{
    public static void main(String[] args) {
        Wind flute = new Wind();
        Instrument.tune(flute); //Upcasting
    }
}
/**
 * 在此例中，tune()方法可以接受Instrument引用，这实在太有趣了。但在Wind.main()中，
 * 传递给tune()方法的是一个Wind引用。鉴于Java对类型的检查十分严格，接受某种类型的
 * 方法同样可以接受另外一种类型就会显得奇怪，除非你认识到Wind对象同样也是一种Instrument
 * 对象，而且也不存在任何tune()方法是可以通过Instrument来调用，同时又不存在于Wind之中。
 * 在tune()中，程序代码可以对Instrumeng和它所有的导出类起作用，这种将Wind引用转换为
 * Instrument引用的动作，我们称之为向上转型。
 */
/**
 * 为什么称为向上转型
 * 该术语的使用有其历史原因，并且是以传统的类继承图的绘制方法为基础的：将根置于页面
 * 的顶端，然后逐渐向下。（当然也可以以任何你认为有效的方法进行绘制。）于是，Wind.java
 * 的继承图就是
 *             _________
 *            |         |
 *            |Insrument|
 *            |_________|
 *                 ^
 *                 |
 *             ____|_____
 *            |         |
 *            |   Wind  |
 *            |_________|
 *
 *
 * 由导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型。因此
 * 一般称为向上转型。由于向上转型是一个较专用类型向较通用类型转换，所以总是
 * 很安全的。也就是说，导出类是基类的一个超集。它肯能比基类含有更多的方法，
 * 但它必须至少具备基类中所含有的方法。在向上转型的过程中，类接口中唯一可能
 * 发生的事情是丢失方法，而不是获取它们。这就是为什么编译器在"未曾明确表示转型"
 * 或"未曾指定特殊标记"的情况下，任然允许向上转型的原因。
 * 也可以执行与向上转型相反的向下转型，但其中含有一个难题，这将在第8章和第14章
 * 中进一步解释
 */
/**
 * 再论组合与继承
 * 在面向对象编程中，生成和使用程序代码最有可能采用的方法就是直接将数据和方法包装
 * 进一个类中，并使用该类的对象。也可以运用组合技术使用现有类来开发新的类；而继承
 * 技术其实是不太常用的。因此，尽管在教授OOP的过程中我们多次强调继承，但这并不意味
 * 着要尽可能使用它。相反，应当慎用这一技术，其使用场合仅限于你确信使用该技术确实
 * 有效的情况。到底是该用组合还是继承，一个最清晰的判断方法是问一问自己是否需要从新
 * 类向基类进行向上转型。如果必须向上转型，则继承是必须的；但如果不需要，则应当好好
 * 考虑自己是否需要继承。第8章提出了一个使用向上转型的最具说服力的理由，但只要记得
 * 自问一下"我真的需要向上转型吗？"就能较好地在这两种技术中做出决定。
 */
/**
 * 根据上下文环境，Java的关键字final的含义存在着细微的区别，
 * 但通常它指的是"这是无法改变的。"不想做改变可能出于两种理由：
 * 设计或效率。由于这两个原因相差很远，所以关键字final有可能误用。
 * 以下几节讨论了可能使用到final的三种情况：数据、方法和类。
 *
 */