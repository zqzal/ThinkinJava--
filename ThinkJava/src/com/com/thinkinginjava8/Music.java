package com.com.thinkinginjava8;

/**
 * Created by xuxi on 2019/2/26.
 */

/**
 * 多态
 *  在面向对象的设计语言中，多态是继数据抽象和继承之后的第三种基本特征。
 *  多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开来。多态不但能够改善代码的
 *  组织结构和可读性，还能够创建可扩展的程序————即无论在项目中最初创建时还是在需要添加
 *  新的功能时都可以"生长"的程序。
 *  "封装"通过合并特征和行为来创建新的数据类型。"实现隐藏"则通过细节"私有化"把接口和实现
 *  分离开来。这种类型的组织机制对那些拥有过程化程序设计背景的人来说，更容易理解。而多态
 *  的作用则是消除类型之间的耦合关心。这种能力极为重要，因为它允许将多种类型（从同一基类
 *  导出的）视为同一类型来处理，而同一份代码也就可以毫无差别地运行在这些不同类型之上了。
 *  多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一基类导出而
 *  来的。这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。
 *  在本章中，通过一些基本、简单的例子（这些例子中所有与多态无关的代码都被删掉，只剩下与
 *  多态有关的部分），深入浅出地介绍多态（也称作动态绑定、后期绑定或运行绑定）。
 */

import com.sun.tools.corba.se.idl.constExpr.Not;

/**
 * 再论向上转型
 * 在第7章中我们已经知道，对象即可以作为它自己本身的类型使用，也可以作为它的基类型使用。
 * 而这种把某个对象的引用视为对其基本类型的引用的做法被称作向上转型————因为在继承树的
 * 画法中，基类是放置在上方的。
 * 但是，这样做的也有一个问题，具体看下面这个有关乐器的例子。
 * 首先，既然几个例子都是演奏乐符（Note），我们就应该在包中单独创建一个Note类。
 */

/**
 * Music.tune()方法接受一个Instrument引用，同时也接受任何导出自Instrument的类。在
 * mian()方法中，当一个Wind引用传递到tune()方法时，就会出现这种情况，当不需要任何类型
 * 转换。这样做是允许的—————因为Wind从Instrumeng继承而来，所以Instrument的接口必定
 * 存在于Wind中。从Wind向上转型到instrument可能会"缩小"接口，但不会Instrument的全部
 * 接口更窄。
 */

/**
 * 8.1.1 忘记对象类型
 * Music.java看起来似乎有些奇怪。为什么所有人都故意忘记对象的类型呢？在进行向上转型时，
 * 就会产生这种情况，并且如果让tune()方法直接接受一个Wind引用作为自己的参数，似乎会更为
 * 直观。但这样引发的一个重要问题是：如果那样做，就需要为系统内Instrument的每种类型都编写
 * 一个新的tune()方法。假设按照这种推理，现在再加入Stringed(弦乐)和Brass(管乐)
 */
public class Music {
    public static void tune(Instrument i){
        i.play(Note.MIDDLE_C);
    }
    public static void main(String[] args) {
          Wind flute = new Wind();
          tune(flute);
    }
}
