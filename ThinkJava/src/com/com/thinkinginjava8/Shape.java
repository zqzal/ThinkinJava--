package com.com.thinkinginjava8;

/**
 * Created by xuxi on 2019/3/4.
 */

/**
 * 转机
 * 运行这个程序后，我们便会发现Music.java的难点所在。Wind.play()方法将产生输出结果。这无疑是我们
 * 所期望的输出结果，但它看起来似乎又没有什么意义。请观察一下tune()方法：
 *    public static void tune(Instrument i){
 *        i.play(Note.MIDDLE_C);
 *    }
 * 它接受一个Instrument引用。那么在这种情况下，编译器怎样才能知道这个Instrument引用指向的是Wind
 * 对象，而不是Brass对象或Stringed对象呢？实际上，编译器无法得知。为了深入理解这个问题，有必要研究
 * 一下绑定这个话题。
 */

/**
 * 方法调用绑定
 * 将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现）
 * ，叫做前期绑定。读者可能以前从来没有听说过这个术语。因为它是面向过程的语言不需要选择就默认的绑定方式，例如，
 * C只有一种方法调用，那就是前期绑定。
 * 上述程序之所以令人迷惑，主要是因为前期绑定。因为，当编译器只有一个Instrument引用时，它无法知道究竟调用
 * 那个方法才对。
 * 解决的办法就是后期绑定，它的含义就是在运行时根据对象的类型就行绑定。后期绑定也叫做动态绑定或运行时绑定。如果
 * 一种语言想实现后期绑定，就必须具有某种机制。以便在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器
 * 一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。后期绑定机制随编程语言的不同而有所不能，
 * 但是只要想一下就会得知，不管怎样都必须在对象中安置某种"类型信息"。
 * Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。这意味着通常
 * 情况下，我们不必判定是否应该进行后期绑定——————它会自然发生。
 * 为什么要将某个方法声明为final呢？正如前一章提到的那样，它可以防止其他人覆盖该方法。但更重要的一点或许是：这样
 * 做可以有效地"关闭"动态绑定，或者说，告诉编译器不需要对其进行动态绑定。这样，编译器就可以为final方法调用生成
 * 更有效的代码。然而，大多数情况下，这样做程序的整体性能不会有什么改观。所以，最好根据设计来决定是否使用final，
 * 而不是出于试图提高性能的目的来使用final。
 */

/**
 * 产生正确的行为
 * 一旦知道Java中所有方法都是通过动态绑定实现多态这个事实之后，我们就可以编写只与基类打交道的程序代码了，并且
 * 这些代码对所有的导出类都可以正确运行。或者换一种说法，发送消息给某个对象，让该对象去断定应该做什么事。
 * 面向对象程序设计中，有一个经典的例子就是"几何形状"（shape）。因为它很直观，所以经常用到，但不幸的是，它可能
 * 使初学者认为面向对象程序设计仅适用于图形化程序设计，实际当然不是这样。
 * 在"几何形状"这个例子中，有一个基类Shape，以及多个导出类————如Circle、Square、Triangle等。这个例子之所
 * 以好用，是因为我们都可以说"圆是一种几何形状"，这种说法也很容易被理解。下面的继承图展示它们之间的关系：
 *
 *
 *
 *  向上转型可以像下面这条语句这么简单：
 *   Shape s = new Circle();
 *  这里，创建了一个Circle对象，并把得到的引用立即赋值给Shape，这样做看似错误（将一种类型赋值给另一种类型）；
 *  但实际上是没问题的，因为通过继承，Circle就是一种Shape。因此，编译器认可这条语句，也就不会产生错误信息。
 *  假设你调用一个基类方法（它已在导出类中被覆盖）：
 *  s.draw();
 *  你可能再次认为调用的是Shape的draw(),因为这毕竟是一个Shape引用，那么编译器是怎样知道去做其他的事情呢？
 *  由于后期绑定（多态），还是正确调用了Circle.draw()方法。
 *
 */
public class Shape {

    public void draw(){

    }
    public void erase(){

    }

}



